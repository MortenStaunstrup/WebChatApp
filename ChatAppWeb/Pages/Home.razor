@page "/"
@using System.Net
@using Microsoft.AspNetCore.SignalR.Client
@using Core
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject NavigationManager NavMan
@inject HttpClient Client
@inject IJSRuntime JS

<PageTitle>Messages</PageTitle>

<!-- Todo: 
    5. Reduce redundancy in code (make some code into functions)
    10. Make pagination and limit for previousConversations
    11. Scroll to bottom for messages logic is faulty, because it does it not when the messages are loaded, but at a time interval
    12. Make UI prettier (probably never going to happen)
    13. Improve tutorial with sample data (use smartman@smartman.com, Smartman123) to test
    14. IMPORTANT!! Previous conversations get doubled when writing a new message
    15. Der er fejl ved nye brugere
    16. Profile picture bliver ikke updatet i update user (man ser det ikke når man reloader update profile page)
    17. Front page has weird height of nothing above it self
-->

@if (_currentUser == null)
{
    <div style="display: flex; justify-content: center; align-items: center; flex-direction: column; height: 100vh;">
        <div class="loader"></div>
        <span>Authenticating...</span>
    </div>
}
else
{
    @if (messageNotSent)
    {
        <div class="alerts alert alert-danger" role="alert">
            Message could not be sent
        </div>
    } else if (messageSentNotFound)
    {
        <div class="alerts alert alert-danger" role="alert">
            Message could not be found in the database
        </div>
    } else if (fileCouldNotBeUploaded)
    {
        <div class="alerts alert alert-danger" role="alert">
            File could not be uploaded
        </div>
    } else if (fileSizeTooLarge)
    {
        <div class="alerts alert alert-danger" role="alert">
            File size too large
        </div>
    } else if (downloadFailed)
    {
        <div class="alerts alert alert-danger" role="alert">
            File could not be downloaded
        </div>
    }

    if (tutorial)
    {
        <div id="tutorialDiv1" style="display: @(tutStage == 1 ? "block" : "none")">Here you can search for users to talk to, by clicking the searchbar at the top and searching for an existing user</div>
        <div id="tutorialDiv2" style="display: @(tutStage == 2 ? "block" : "none")">Users will appear here, and you can start a conversation with them</div>
        <div id="tutorialDiv3" style="display: @(tutStage == 3 ? "block" : "none")">Previous conversations will be displayed over here, sorted by newest</div>
        <div id="tutorialDiv4" style="display: @(tutStage == 4 ? "block" : "none")">You can send messages by pressing the "Enter" key on pc, or pressing the send button in the send message box</div>
        <div id="tutorialDiv5" style="display: @(tutStage == 5 ? "block" : "none")">The image button allows you to send files to somebody</div>
        <div id="tutorialEnd" style="display: @(tutStage == 6 ? "block" : "none")">That is all, have fun and remember, never write to somebody what you wouldn't say to them in person</div>
    }
    
    <div class="main">
        

        <div class="usersDiv">

            <div class="userSearchDiv">
                <InputText @bind-Value="_newUserSearch" id="userSearchInput"
                           @oninput="OnSearchChange"
                           @onfocus="ShowDropdown"
                           placeholder="Start new conversation..." class="inputStyle"></InputText>
                @if (showDropdown)
                {
                    <div class="searchedPeoplesDropdown" id="userSearchDropdown">
                        @if (_searchedUsers.Count == 0 && string.IsNullOrWhiteSpace(_newUserSearch))
                        {
                            <p>Begin searching for a user to connect with</p>
                        }
                        else
                        {
                            if (_searchedUsers.Count > 0)
                            {
                                @foreach (var user in _searchedUsers)
                                {
                                    @if (!string.IsNullOrWhiteSpace(_newUserSearch))
                                    {
                                        <div @onclick="() => StartConvoWith(user.UserId)" class="userCard">
                                            <img alt="profile pic" src="@(user.ProfilePicture ?? "Pictures/noPic.png")"/>
                                            <span>@user.FirstName @user.LastName</span>
                                        </div>
                                    }
                                }
                                <span @onclick="ShowMoreUsers" style="color: blue; text-decoration: underline; display: @(moreUsers ? "flex" : "none"); justify-content: center;" class="showMore">See more...</span>
                            }
                            else
                            {
                                <p>No user with name found</p>
                            }
                        }
                    </div>
                }
            </div>

            <div class="conversationsDiv">
                @if (hasPreviousConversations)
                {
                    // Two List, one for conversations, other for user tied to the conversations.
                    // Determines whether to show current users name, or other user
                    @foreach (var (x, y) in _previousConversations.Zip(_usersForPreviousConversations))
                    {
                        <div class="convoCard" @onclick="() => OpenConvoCard(x.PersonAId, x.PersonBId)">
                            <img alt="convo profile pic" src="@(y.ProfilePicture ?? "Pictures/noPic.png")"/>

                            <div class="convoCardBuffer">
                                <span>@y.FirstName @y.LastName</span>

                                @if (x.SenderId != _currentUser.UserId && x.SeenByReceiver)
                                {
                                    <span style="font-size: 14px; color: grey">@y.FirstName @y.LastName: @x.LastMessage</span>
                                    <span style="font-size: 14px; color: grey">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>

                                }
                                else if (x.SenderId != _currentUser.UserId && x.SeenByReceiver == false)
                                {
                                    <span style="font-size: 14px; color: black"><b>@y.FirstName @y.LastName: @x.LastMessage</b></span>
                                    <span style="font-size: 14px; color: black">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>
                                }
                                else
                                {
                                    <span style="font-size: 14px; color: grey">You: @x.LastMessage</span>
                                    <span style="font-size: 14px; color: grey">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>
                                }
                            </div>
                        </div>
                    }
                    <span style="color: blue; text-decoration: underline; display: @(noMoreConversations ? "none" : "flex"); justify-content: center;" class="showMore" @onclick="ShowMoreConversations">See more...</span>
                }
            </div>

        </div>

        <div class="messagesDiv">
            <div class="convoBanner">
                <div>
                    @if (userFound)
                    {
                        <img alt="profile pic" src="@(_otherPerson.ProfilePicture ?? "Pictures/noPic.png")"/>
                        <span>@_otherPerson.FirstName @_otherPerson.LastName</span>
                    }
                </div>

                <div style="display: flex">
                    <div id="myProfileLink">
                        <a href="/myprofile">My Profile</a>
                    </div>

                    <div id="logoutLink">
                        <a href="/logout">Logout</a>
                    </div>
                </div>

            </div>
            <div class="messagesContainer" id="scrollBottom">
                @if (userFound && hasMessages && clickedUser && _currentConvoMessages.Count > 0)
                {
                    <span style="color: blue; text-decoration: underline; display: @(noMoreMessages ? "none" : "flex"); justify-content: center;" class="showMore" @onclick="ShowMoreMessages">Show more...</span>
                    for (int i = _currentConvoMessages.Count - 1; i >= 0; i--)
                    {
                        var message = _currentConvoMessages[i];
                        if (timeMap.Contains(message.MessageId))
                        {
                            <span class="messageTimestamp">@(message.Timestamp.Day == DateTime.Now.Day ? message.Timestamp.ToString("HH:mm") : message.Timestamp.ToString("dd-MMMM HH:mm"))</span>
                        }

                        if (message.Sender == _currentUser.UserId)
                        {
                            <div class="bufferDiv">
                                <div class="userMessage" @onclick="() => ShowTimestamp(message.MessageId)">
                                    @if (message.IsFile)
                                    {
                                        <span @onclick="() => DownloadFile(message.MessageId)" style="color: blue; text-decoration: underline" class="messageContent">@message.Content</span>
                                    }
                                    else
                                    {
                                        <span class="messageContent">@message.Content</span>
                                    }
                                    
                                </div>
                                @if (message.MessageId == lastSeenMessageByReceiver)
                                {
                                    <img id="seenPicture" alt="picture of other person" src=@(_otherPerson.ProfilePicture ?? "Pictures/noPic.png")/>
                                }
                            </div>
                        }
                        else
                        {
                            <div class="receiverMessage" @onclick="() => ShowTimestamp(message.MessageId)">
                                @if (message.IsFile)
                                {
                                    <span @onclick="() => DownloadFile(message.MessageId)" style="color: blue; text-decoration: underline" class="messageContent">@message.Content</span>
                                }
                                else
                                {
                                    <span class="messageContent">@message.Content</span>
                                }
                            </div>
                        }
                    }
                }
                else if (!userFound && clickedUser)
                {
                    <p>This user does not exist??</p>
                }
                else if (!hasMessages && clickedUser)
                {
                    // TODO Needs amazing styling
                    <p>Begin your conversation with @_otherPerson.FirstName @_otherPerson.LastName</p>
                }
            </div>

            <div class="inputDiv">
                <InputText @bind-Value="newText" @onkeyup="Enter" class="inputMessage" placeholder="Send message"></InputText>
                <svg @onclick="() => SendMessage()" class="sendIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M15.854.146a.5.5 0 0 1 .11.54l-5.819 14.547a.75.75 0 0 1-1.329.124l-3.178-4.995L.643 7.184a.75.75 0 0 1 .124-1.33L15.314.037a.5.5 0 0 1 .54.11ZM6.636 10.07l2.761 4.338L14.13 2.576zm6.787-8.201L1.591 6.602l4.339 2.76z"/>
                </svg>
                <label for="inputfile"><img style="width: 30px" src="Pictures/image-plus-svgrepo-com.svg" alt="Upload files"/></label>
                <InputFile id="inputfile" OnChange="HandleFile" hidden></InputFile>
            </div>
        </div>

    </div>
        
}



@code{
    const string socketAzure = "https://chatappmesocket.azurewebsites.net";
    const string socketLocalHost = "http://localhost:5150";
    
    User? _currentUser;
    User? _otherPerson;

    List<User> _searchedUsers = new List<User>();
    string? _newUserSearch;
    const int _newUserPaging = 10;
    int _newUserSearchPage = 0;
    bool moreUsers = true;

    string? newText;

    byte[]? fileBytes;
    const int maxFileNameLength = 20;
    bool fileCouldNotBeUploaded;
    bool fileSizeTooLarge;
    bool downloadFailed;
    const long maxFileSize = 50000000;
    
    string noPicString = "Pictures/noPic.png";

    bool hasPreviousConversations = false;
    Conversation currentConvo;
    List<Conversation> _previousConversations = new List<Conversation>();
    List<User> _usersForPreviousConversations = new List<User>();
    List<Message> _currentConvoMessages;
    const int _convoPaging = 15;
    int _convoPage = 0;
    bool noMoreConversations = false;
    bool hasMessages;
    bool userFound;
    bool clickedUser;
    bool messageNotSent;
    bool messageSentNotFound;
    int lastSeenMessageByReceiver;
    const int _messagePaging = 15;
    int _messagePage = 0;
    bool noMoreMessages = false;

    HashSet<int> timeMap = new HashSet<int>();
    
    bool showDropdown;

    HubConnection? hubConnection;
    
    DotNetObjectReference<Home>? dotNetHelper;
    
    bool shouldScrollToBottom = false;

    bool tutorial = false;
    int tutStage = 0;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetHelper = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("registerOutsideClick", "userSearchInput", "userSearchDropdown", dotNetHelper);
        }

        if (shouldScrollToBottom)
        {
            shouldScrollToBottom = false;
            // Hack to make scroll to bottom work. Otherwise the content might not be rendered and scrollToBottom wouldn't work
            await Task.Delay(50);
            await JS.InvokeVoidAsync("scrollToBottom");
        }
    }
    
    [JSInvokable]
    public void CloseDropdown()
    {
        showDropdown = false;
        InvokeAsync(StateHasChanged);
    }
    
    private void ShowDropdown() => showDropdown = true;
    
    protected override async Task OnInitializedAsync()
    {
        _currentUser = await LocalStorage.GetItemAsync<User>("user");
        
        if (_currentUser != null)
        {
            
            await GetConversations();

            await ConnectToWebSocketServer();
        }
        else
        {
            NavMan.NavigateTo("/login");
        }

        if (_previousConversations.Count == 0)
        {
            StartTutorial();
            StateHasChanged();
        }
    }

    private void StartTutorial()
    {
        tutorial = true;
        _searchedUsers = new List<User>()
        {
            new User()
            {
                FirstName = "Michelle",
                LastName = "Arlington",
                Email = "saf",
                Password = "adf",
                PhoneNumber = "35235",
                UserId = 0,
                ProfilePicture = "Pictures/Michelle.jpg"
            },
            new User()
            {
                FirstName = "Mikael",
                LastName = "Bourne",
                Email = "saf",
                Password = "adf",
                PhoneNumber = "35235",
                UserId = 0,
                ProfilePicture = "Pictures/Mikael.jpg"
            }
        };
        _previousConversations = new List<Conversation>()
        {
            new Conversation()
            {
                ConversationId = 0,
                LastMessage = "Are you joining the meetup later today?",
                PersonAId = _currentUser.UserId,
                PersonBId = 0,
                SeenByReceiver = false,
                SenderId = 0,
                Timestamp = DateTime.Now.ToLocalTime()
            },
            new Conversation()
            {
                ConversationId = 0,
                LastMessage = "John you absolute legend haha",
                PersonAId = _currentUser.UserId,
                PersonBId = 0,
                SeenByReceiver = true,
                SenderId = _currentUser.UserId,
                Timestamp = DateTime.Now.Subtract(new TimeSpan(2, 4, 2)).ToLocalTime()
            }
        };
        _usersForPreviousConversations = new List<User>()
        {
            new User()
            {
                FirstName = "Camilla",
                LastName = "Neville",
                Email = "saf",
                Password = "adf",
                PhoneNumber = "35235",
                UserId = 0,
                ProfilePicture = "Pictures/Camilla.jpg"
            },
            new User()
            {
                FirstName = "John",
                LastName = "Doe",
                Email = "saf",
                Password = "adf",
                PhoneNumber = "35235",
                UserId = 0,
                ProfilePicture = "Pictures/john.jpg"
            }
        };
        tutStage = 1;
        JS.InvokeVoidAsync("TutorialClick", dotNetHelper);
        StateHasChanged();
    }

    [JSInvokable]
    public async void ContinueTutorial()
    {
        _newUserSearch = "";
        CloseDropdown();
        tutStage++;
        if (tutStage == 2)
        {
            _newUserSearch = "Mi";
            ShowDropdown();
        }
        if (tutStage == 3)
        {
            hasPreviousConversations = true;
        }
        if (tutStage > 6)
        {
            _searchedUsers = new List<User>();
            _previousConversations = new List<Conversation>();
            _usersForPreviousConversations = new List<User>();
            hasPreviousConversations = false;
            tutorial = false;
            await JS.InvokeVoidAsync("RemoveTutorialClick");
        }
        StateHasChanged();
    }

    private async Task GetConversations()
    {
        _convoPage = 0;
        var response = await Client.GetAsync($"conversations/getConversations/{_currentUser.UserId}/{_convoPaging}/{_convoPage}");

        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                noMoreConversations = false;
                var conversationsContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
                _previousConversations.AddRange(conversationsContainer.Conversations);

                foreach (var conversation in _previousConversations)
                {
                    conversation.Timestamp = conversation.Timestamp.ToLocalTime();
                }
                _usersForPreviousConversations.AddRange(conversationsContainer.Users);
                hasPreviousConversations = true;
                break;
                
            case HttpStatusCode.Accepted:
                noMoreConversations = true;
                var lastConversationContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
                _previousConversations.AddRange(lastConversationContainer.Conversations);

                foreach (var conversation in _previousConversations)
                {
                    conversation.Timestamp = conversation.Timestamp.ToLocalTime();
                }
                _usersForPreviousConversations.AddRange(lastConversationContainer.Users);
                hasPreviousConversations = true;
                break;
                
            case HttpStatusCode.NoContent:
                noMoreConversations = true;
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oops... Something went wrong");
                break;
        }
        StateHasChanged();
    }

    private async Task GetSpecificConversation(int userId)
    {
        var convoResponse = await Client.GetAsync($"conversations/get/{_currentUser.UserId}/{userId}");

        switch (convoResponse.StatusCode)
        {
            case HttpStatusCode.OK:
                currentConvo = await convoResponse.Content.ReadFromJsonAsync<Conversation>();
                if (currentConvo.SenderId != _currentUser.UserId)
                {
                    currentConvo.SeenByReceiver = true;
                    _previousConversations.Find(x => x.ConversationId == currentConvo.ConversationId).SeenByReceiver = true;
                
                    var update = await Client.PostAsJsonAsync($"conversations/updateSeenStatus", currentConvo);
                    if (!update.IsSuccessStatusCode)
                    {
                        Console.WriteLine("An error occured trying to update seen status");
                    }
                }

                hasPreviousConversations = true;
                break;
                
            case HttpStatusCode.NotFound:
                var newConvo = new Conversation
                {
                    ConversationId = 0,
                    LastMessage = "",
                    PersonAId = _currentUser.UserId,
                    PersonBId = userId,
                    SeenByReceiver = false,
                    Timestamp = DateTime.Now,
                    SenderId = _currentUser.UserId
                };
                var existingConvoIndex = _previousConversations.FindIndex(c => c.ConversationId == 0);
                currentConvo = newConvo;

                if (existingConvoIndex != -1)
                {
                    _previousConversations.RemoveAt(existingConvoIndex);
                    _usersForPreviousConversations.RemoveAt(existingConvoIndex);
                }
                
                _previousConversations.Insert(0, currentConvo);
                _usersForPreviousConversations.Insert(0, _otherPerson);   
                
                hasPreviousConversations = true;
                break;
        }
        
        StateHasChanged();
    }

    private async Task GetMessages(int userId)
    {
        _messagePage = 0;
        var response = await Client.GetAsync($"messages/getMessages/{_currentUser.UserId}/{userId}/{_messagePaging}/0");

        if (response.IsSuccessStatusCode)
        {
            noMoreMessages = response.StatusCode == HttpStatusCode.Accepted;
            
            _currentConvoMessages = await response.Content.ReadFromJsonAsync<List<Message>>();
            
            // Find the last seen message by other person
            for (int i = 0; i < _currentConvoMessages.Count; i++)
            {
                if (_currentConvoMessages[i].Sender == _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == true)
                {
                    lastSeenMessageByReceiver = _currentConvoMessages[i].MessageId;
                    break;
                }
            }

            await UpdateSeenMessages();

            foreach (var message in _currentConvoMessages)
            {
                message.Timestamp = message.Timestamp.ToLocalTime();
            }
            
            hasMessages = true;
            StateHasChanged();
        } else if (response.StatusCode == HttpStatusCode.Conflict || response.StatusCode == HttpStatusCode.NotFound)
        {
            _currentConvoMessages = new List<Message>();
            hasMessages = false;
            StateHasChanged();
        }
    }

    private async Task UpdateSeenMessages()
    {
        var newMessages = new List<Message>();
        
        // Update seenByReceiver status for messages received by user
        for (int i = 0; i < _currentConvoMessages.Count; i++)
        {
            if (_currentConvoMessages[i].Sender != _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == false)
            {
                _currentConvoMessages[i].SeenByReceiver = true;
                newMessages.Add(_currentConvoMessages[i]);
            } else if (_currentConvoMessages[i].Sender != _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == true)
            {
                break;
            }
        }

        await Client.PostAsJsonAsync("messages/updateSeen", newMessages);
    }
    
    private async Task OnSearchChange(ChangeEventArgs e)
    {
        _searchedUsers = new List<User>();
        _newUserSearchPage = 0;
        _newUserSearch = e.Value.ToString();
        var response = await Client.GetAsync($"auth/getquery/{_newUserSearch}/{_newUserPaging}/0");
        
        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                moreUsers = true;
                _searchedUsers = await response.Content.ReadFromJsonAsync<List<User>>();
                StateHasChanged();
                break;
                
            case HttpStatusCode.Accepted:
                _searchedUsers = await response.Content.ReadFromJsonAsync<List<User>>();
                moreUsers = false;
                StateHasChanged();
                break;
                
            case HttpStatusCode.NoContent:
                moreUsers = false;
                StateHasChanged();
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oh no, something went wrong!!!");
                break;
        }
    }

    private async Task ShowMoreUsers()
    {
        _newUserSearchPage++;
        var response = await Client.GetAsync($"auth/getquery/{_newUserSearch}/{_newUserPaging}/{_newUserSearchPage}");
        
        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                moreUsers = true;
                List<User> newUsers = await response.Content.ReadFromJsonAsync<List<User>>();
                _searchedUsers.AddRange(newUsers);
                break;
                
            case HttpStatusCode.Accepted:
                List<User> lastUsers = await response.Content.ReadFromJsonAsync<List<User>>();
                _searchedUsers.AddRange(lastUsers);
                moreUsers = false;
                break;
                
            case HttpStatusCode.NoContent:
                moreUsers = false;
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oh no, something went wrong!!!");
                break;
                
        }
        StateHasChanged();
    }
    
    private async Task ShowMoreMessages()
    {
        _messagePage++;
        var response = await Client.GetAsync($"messages/getMessages/{_currentUser.UserId}/{_otherPerson.UserId}/{_messagePaging}/{_messagePage}");
        
        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                List<Message> moreMessages = await response.Content.ReadFromJsonAsync<List<Message>>();
                _currentConvoMessages.AddRange(moreMessages);
                noMoreMessages = false;
                break;
                
            case HttpStatusCode.Accepted:
                List<Message> lastMessages = await response.Content.ReadFromJsonAsync<List<Message>>();
                _currentConvoMessages.AddRange(lastMessages);
                noMoreMessages = true;
                break;
                
            case HttpStatusCode.NoContent:
                noMoreMessages = true;
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oh no, something went wrong!!!");
                break;
        }
        StateHasChanged();
    }

    private async Task ShowMoreConversations()
    {
        _convoPage++;
        var response = await Client.GetAsync($"conversations/getConversations/{_currentUser.UserId}/{_convoPaging}/{_convoPage}");

        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                noMoreConversations = false;
                var conversationsContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
                _previousConversations.AddRange(conversationsContainer.Conversations);

                foreach (var conversation in _previousConversations)
                {
                    conversation.Timestamp = conversation.Timestamp.ToLocalTime();
                }
                _usersForPreviousConversations.AddRange(conversationsContainer.Users);
                hasPreviousConversations = true;
                break;
                
            case HttpStatusCode.Accepted:
                noMoreConversations = true;
                var lastConversationContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
                _previousConversations.AddRange(lastConversationContainer.Conversations);

                foreach (var conversation in _previousConversations)
                {
                    conversation.Timestamp = conversation.Timestamp.ToLocalTime();
                }
                _usersForPreviousConversations.AddRange(lastConversationContainer.Users);
                hasPreviousConversations = true;
                break;
                
            case HttpStatusCode.NoContent:
                noMoreConversations = true;
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oops... Something went wrong");
                break;
        }
        StateHasChanged();
    }

    private async Task HandleFile(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            if (file.Size > maxFileSize)
            {
                await FileSizeTooLargeError();
                fileBytes = null;
                return;
            }
            using var memoryStream = new MemoryStream();
            await file.OpenReadStream(maxFileSize).CopyToAsync(memoryStream);
            fileBytes = memoryStream.ToArray();

            newText = file.Name.Length > maxFileNameLength ? file.Name.Substring(0, maxFileNameLength) : file.Name;
           
            MessageFileContainer container = new MessageFileContainer
            {
                FileName = file.Name,
                SenderId = _currentUser.UserId,
                File = fileBytes
            };
            var uploadResponse = await Client.PostAsJsonAsync("messages/sendFile", container);
            
            if (uploadResponse.StatusCode == HttpStatusCode.BadRequest)
            {
                await FileCouldNotBeUploadedError();
                return;
            }
            
            var path = await uploadResponse.Content.ReadAsStringAsync();
            
            await SendMessage(true, path);
        }
        else
        {
            fileBytes = null;
        }
    }
    
    private async Task DownloadFile(int messageId)
    {
        var response = await Client.GetAsync($"messages/getFile{messageId}");
        if (response.StatusCode == HttpStatusCode.Conflict)
        {
            await FileCouldNotBeDownloadedError();
            return;
        }
        var NameByteContainer = await response.Content.ReadFromJsonAsync<ByteNameContainer>();
        var asMemStream = new MemoryStream(NameByteContainer.Bytes);

        using var streamRef = new DotNetStreamReference(asMemStream);

        await JS.InvokeVoidAsync("downloadFileFromStream", NameByteContainer.FileName, streamRef);
    }
    
    private void Enter(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        { 
            SendMessage();
        }
    }

    private async Task SendMessage(bool isFile = false, string path = "")
    {
        if (_otherPerson == null || _currentUser == null)
        {
            newText = "";
            return;
        }

        if(string.IsNullOrWhiteSpace(newText))
            return;

        Message newMess;
        
        if (isFile)
        {
            newMess = new Message()
            {
                Content = newText,
                MessageId = 0,
                Receiver = _otherPerson.UserId,
                Sender = _currentUser.UserId,
                Timestamp = DateTime.MinValue,
                IsFile = isFile,
                FileURL = path
            };
        }
        else
        {
            newMess = new Message()
            {
                Content = newText,
                MessageId = 0,
                Receiver = _otherPerson.UserId,
                Sender = _currentUser.UserId,
                Timestamp = DateTime.MinValue,
                IsFile = isFile
            };
        }

        if (currentConvo.LastMessage == "")
        {
            currentConvo.LastMessage = newText;
            var postConvoResponse = await Client.PostAsJsonAsync("conversations/create", currentConvo);
            _previousConversations = new List<Conversation>();
            _usersForPreviousConversations = new List<User>();
            await GetConversations();
        }

        
        var response = await Client.PostAsJsonAsync("messages/createMessage", newMess);
        if (response.IsSuccessStatusCode)
        {
            var sentMessageId = await response.Content.ReadFromJsonAsync<int>();
            var newResponse = await Client.GetAsync($"messages/getSentMessage/{sentMessageId}");
            if (newResponse.IsSuccessStatusCode)
            {
                var message = await newResponse.Content.ReadFromJsonAsync<Message>();
                message.Timestamp = message.Timestamp.ToLocalTime();
                _currentConvoMessages.Insert(0, message);
                currentConvo.LastMessage = newText;
                currentConvo.SenderId = _currentUser.UserId;
                currentConvo.SeenByReceiver = false;
                
                hasMessages = true;
                
                var update = await Client.PostAsJsonAsync("conversations/update", currentConvo);
                if (update.IsSuccessStatusCode)
                {
                    var index = _previousConversations.FindIndex(x => x.ConversationId == currentConvo.ConversationId);
                    _previousConversations[index].LastMessage = newText;
                    _previousConversations[index].SenderId = _currentUser.UserId;
                    _previousConversations[index].SeenByReceiver = false;
                    _previousConversations[index].Timestamp = DateTime.UtcNow.ToLocalTime();

                    var zipped = _previousConversations
                        .Zip(_usersForPreviousConversations, (conv, user) => new { conv, user })
                        .OrderByDescending(x => x.conv.Timestamp)
                        .ToList();

                    _previousConversations = zipped.Select(x => x.conv).ToList();
                    _usersForPreviousConversations = zipped.Select(x => x.user).ToList();
                    
                    if (hubConnection is not null)
                        await hubConnection.InvokeAsync("UpdateReceiverMessages", _otherPerson.UserId, _currentUser.UserId);
                    shouldScrollToBottom = true;
                }
                else
                {
                    Console.WriteLine("Something went wrong updating conversations with new text");
                }
                
                newText = "";
                
                StateHasChanged();
            }
            else
            {
                await ShowSentMessageCouldntBeFoundError();
            }
        }
        else
        {
            await ShowMessageNotSentError();
        }

    }

    private async Task ShowMessageNotSentError()
    {
        messageNotSent = true;
        StateHasChanged();
        await Task.Delay(3000);
        messageNotSent = false;
        StateHasChanged();
    }

    private async Task ShowSentMessageCouldntBeFoundError()
    {
        messageSentNotFound = true;
        StateHasChanged();
        await Task.Delay(3000);
        messageNotSent = false;
        StateHasChanged();
    }

    private async Task FileCouldNotBeUploadedError()
    {
        fileCouldNotBeUploaded = true;
        StateHasChanged();
        await Task.Delay(3000);
        fileCouldNotBeUploaded = false;
        StateHasChanged();
    }
    
    private async Task FileCouldNotBeDownloadedError()
    {
        downloadFailed = true;
        StateHasChanged();
        await Task.Delay(3000);
        downloadFailed = false;
        StateHasChanged();
    }
    
    private async Task FileSizeTooLargeError()
    {
        fileSizeTooLarge = true;
        StateHasChanged();
        await Task.Delay(3000);
        fileSizeTooLarge = false;
        StateHasChanged();
    }

    private async Task ConnectToWebSocketServer()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl($"{socketLocalHost}/chatMe?userid={_currentUser.UserId}")
            .Build();

        hubConnection.On<int>("UpdateMessages", UpdateMessages);
        hubConnection.On<int>("UpdateCurrentConvo", UpdateCurrentConvo);
        
        await hubConnection.StartAsync();
    }
    
    // Called from websocket
    private async Task UpdateCurrentConvo(int receiverId)
    {
        if (receiverId == _otherPerson.UserId)
        {
            await GetSpecificConversation(receiverId);

            await GetMessages(receiverId);
        
            clickedUser = true;
        }
        StateHasChanged();
        Console.WriteLine("Messages Updated");
    }
    
    // Called from WebSocket
    private async Task UpdateMessages(int senderId)
    {
        
        await GetConversations();
        
        //If the user sending a message is the user you are having a convo with, update specific convo
        if (senderId == _otherPerson.UserId)
        {
            await GetSpecificConversation(senderId);

            await GetMessages(senderId);
        
            clickedUser = true;
            
            await hubConnection.InvokeAsync("ShowSeen", _currentUser.UserId, _otherPerson.UserId);

        }
        StateHasChanged();
        Console.WriteLine("Messages Updated");
    }
    
    private async Task StartConvoWith(int userId)
    {
        showDropdown = false;
        _newUserSearch = "";
        _searchedUsers = new List<User>();
        var userResponse = await Client.GetAsync($"auth/getUser/{userId}");

        if (userResponse.IsSuccessStatusCode)
        {
            _otherPerson = await userResponse.Content.ReadFromJsonAsync<User>();
            userFound = true;
        }
        else
        {
            clickedUser = true;
            userFound = false;
            StateHasChanged();
            return;
        }

        await GetSpecificConversation(userId);

        await GetMessages(userId);
        
        clickedUser = true;

        if (_currentConvoMessages.Count > 0)
        {
            await hubConnection.InvokeAsync("UpdateReceiverMessages", userId, _currentUser.UserId);
        }
    }

    private void ShowTimestamp(int messageMessageId)
    {

        if (!timeMap.Add(messageMessageId))
        {
            timeMap.Remove(messageMessageId);
        }

        if (timeMap.Count > 1)
        {
            timeMap.Clear();
            timeMap.Add(messageMessageId);
        }
        
        StateHasChanged();
    }

    private async Task OpenConvoCard(int personA, int personB)
    {
        if (personA == _currentUser.UserId)
            await StartConvoWith(personB);
        else
            await StartConvoWith(personA);
    }

    

}