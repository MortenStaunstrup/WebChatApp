@page "/"
@using System.Net
@using Microsoft.AspNetCore.SignalR.Client
@using Core
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject NavigationManager NavMan
@inject HttpClient Client
@inject IJSRuntime JS

<PageTitle>Messages</PageTitle>

<!-- Todo: 
    1. When getting messages, if getting 15 messages and there are no more, the option to 'show more messages' is still there
    (Fetch 1 more message or user to check if more exist)
    3. Make UI prettier (probably never going to happen)
    5. Front page has weird height of nothing above it self
    6. Create Token (use systems design guy on youtube)
-->

@if (_currentUser == null)
{
    <div style="display: flex; justify-content: center; align-items: center; flex-direction: column; height: 100vh;">
        <div class="loader"></div>
        <span>Authenticating...</span>
    </div>
}
else
{
    @if (messageNotSent)
    {
        <div class="alerts alert alert-danger" role="alert">
            Message could not be sent
        </div>
    } else if (messageSentNotFound)
    {
        <div class="alerts alert alert-danger" role="alert">
            Message could not be found in the database
        </div>
    } else if (fileCouldNotBeUploaded)
    {
        <div class="alerts alert alert-danger" role="alert">
            File could not be uploaded
        </div>
    } else if (fileSizeTooLarge)
    {
        <div class="alerts alert alert-danger" role="alert">
            File size too large
        </div>
    } else if (downloadFailed)
    {
        <div class="alerts alert alert-danger" role="alert">
            File could not be downloaded
        </div>
    }
    
    <div class="main">
        

        <div class="usersDiv">

            <div class="userSearchDiv">
                <InputText @bind-Value="_newUserSearch" id="userSearchInput"
                           @oninput="OnSearchChange"
                           @onfocus="ShowDropdown"
                           placeholder="Start new conversation..." class="inputStyle"></InputText>
                @if (showDropdown)
                {
                    <div class="searchedPeoplesDropdown" id="userSearchDropdown">
                        @if (_searchedUsers.Count == 0 && string.IsNullOrWhiteSpace(_newUserSearch))
                        {
                            <p>Begin searching for a user to connect with</p>
                        }
                        else
                        {
                            if (_searchedUsers.Count > 0)
                            {
                                @foreach (var user in _searchedUsers)
                                {
                                    @if (!string.IsNullOrWhiteSpace(_newUserSearch))
                                    {
                                        <div @onclick="() => StartConvoWith(user.UserId)" class="userCard">
                                            <img alt="profile pic" src="@(user.ProfilePicture ?? "Pictures/noPic.png")"/>
                                            <span>@user.FirstName @user.LastName</span>
                                        </div>
                                    }
                                }
                                <span @onclick="ShowMoreUsers" style="color: blue; text-decoration: underline; display: @(moreUsers ? "flex" : "none"); justify-content: center;" class="showMore">See more...</span>
                            }
                            else
                            {
                                <p>No user with name found</p>
                            }
                        }
                    </div>
                }
            </div>

            <div class="conversationsDiv">
                @if (hasPreviousConversations)
                {
                    // Two List, one for conversations, other for user tied to the conversations.
                    // Determines whether to show current users name, or other user
                    @foreach (var (x, y) in _previousConversations.Zip(_usersForPreviousConversations))
                    {
                        <div class="convoCard" @onclick="() => OpenConvoCard(x.PersonAId, x.PersonBId)">
                            <img alt="convo profile pic" src="@(y.ProfilePicture ?? "Pictures/noPic.png")"/>

                            <div class="convoCardBuffer">
                                <span>@y.FirstName @y.LastName</span>

                                @if (x.SenderId != _currentUser.UserId && x.SeenByReceiver)
                                {
                                    <span style="font-size: 14px; color: grey">@y.FirstName @y.LastName: @x.LastMessage</span>
                                    <span style="font-size: 14px; color: grey">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>

                                }
                                else if (x.SenderId != _currentUser.UserId && x.SeenByReceiver == false)
                                {
                                    <span style="font-size: 14px; color: black"><b>@y.FirstName @y.LastName: @x.LastMessage</b></span>
                                    <span style="font-size: 14px; color: black">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>
                                }
                                else
                                {
                                    <div class="userSeenBufferDiv">
                                        <span style="font-size: 14px; color: grey">You: @x.LastMessage</span> <img src="@(y.ProfilePicture ?? "Pictures/noPic.png")" style="display: @(x.SeenByReceiver ? "block" : "none"); width: 12px; height: 12px; margin-right: 0; margin-left: 5px;" alt="User seen your message"/>
                                    </div>
                                    <span style="font-size: 14px; color: grey">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>
                                }
                            </div>
                        </div>
                    }
                    <span style="color: blue; text-decoration: underline; display: @(noMoreConversations ? "none" : "flex"); justify-content: center;" class="showMore" @onclick="ShowMoreConversations">See more...</span>
                }
            </div>

        </div>

        <div class="messagesDiv">
            <div class="convoBanner">
                <div>
                    @if (userFound)
                    {
                        <img alt="profile pic" src="@(_otherPerson.ProfilePicture ?? "Pictures/noPic.png")"/>
                        <span>@_otherPerson.FirstName @_otherPerson.LastName</span>
                    }
                </div>

                <div style="display: flex">
                    <div id="myProfileLink">
                        <a href="/myprofile">My Profile</a>
                    </div>

                    <div id="logoutLink">
                        <a href="/logout">Logout</a>
                    </div>
                </div>

            </div>
            <div class="messagesContainer" id="scrollBottom">
                @if (userFound && hasMessages && clickedUser && _currentConvoMessages.Count > 0)
                {
                    <span style="color: blue; text-decoration: underline; display: @(noMoreMessages ? "none" : "flex"); justify-content: center;" class="showMore" @onclick="ShowMoreMessages">Show more...</span>
                    for (int i = _currentConvoMessages.Count - 1; i >= 0; i--)
                    {
                        var message = _currentConvoMessages[i];
                        if (timeMap.Contains(message.MessageId))
                        {
                            <span class="messageTimestamp">@(message.Timestamp.Day == DateTime.Now.Day ? message.Timestamp.ToString("HH:mm") : message.Timestamp.ToString("dd-MMMM HH:mm"))</span>
                        }

                        if (message.Sender == _currentUser.UserId)
                        {
                            <div class="bufferDiv">
                                <div class="userMessage" @onclick="() => ShowTimestamp(message.MessageId)">
                                    @if (message.IsFile)
                                    {
                                        <span @onclick="() => DownloadFile(message.MessageId)" style="color: blue; text-decoration: underline" class="messageContent">@message.Content</span>
                                    }
                                    else
                                    {
                                        <span class="messageContent">@message.Content</span>
                                    }
                                    
                                </div>
                                @if (message.MessageId == lastSeenMessageByReceiver)
                                {
                                    <img id="seenPicture" alt="picture of other person" src=@(_otherPerson.ProfilePicture ?? "Pictures/noPic.png")/>
                                }
                            </div>
                        }
                        else
                        {
                            <div class="receiverMessage" @onclick="() => ShowTimestamp(message.MessageId)">
                                @if (message.IsFile)
                                {
                                    <span @onclick="() => DownloadFile(message.MessageId)" style="color: blue; text-decoration: underline" class="messageContent">@message.Content</span>
                                }
                                else
                                {
                                    <span class="messageContent">@message.Content</span>
                                }
                            </div>
                        }
                    }
                }
                else if (!userFound && clickedUser)
                {
                    <p>This user does not exist??</p>
                }
                else if (!hasMessages && clickedUser)
                {
                    // TODO Needs amazing styling
                    <p>Begin your conversation with @_otherPerson.FirstName @_otherPerson.LastName</p>
                }
            </div>

            <div class="inputDiv">
                <InputText @bind-Value="newText" @onkeyup="Enter" class="inputMessage" placeholder="Send message"></InputText>
                <svg @onclick="() => SendMessage()" class="sendIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M15.854.146a.5.5 0 0 1 .11.54l-5.819 14.547a.75.75 0 0 1-1.329.124l-3.178-4.995L.643 7.184a.75.75 0 0 1 .124-1.33L15.314.037a.5.5 0 0 1 .54.11ZM6.636 10.07l2.761 4.338L14.13 2.576zm6.787-8.201L1.591 6.602l4.339 2.76z"/>
                </svg>
                <label for="inputfile"><img style="width: 30px" src="Pictures/image-plus-svgrepo-com.svg" alt="Upload files"/></label>
                <InputFile id="inputfile" OnChange="HandleFile" hidden></InputFile>
            </div>
        </div>

    </div>
        
}



@code{
    const string socketAzure = "https://chatappmesocket.azurewebsites.net";
    const string socketLocalHost = "http://localhost:5150";
    
    User? _currentUser;
    User? _otherPerson;

    List<User> _searchedUsers = new List<User>();
    string? _newUserSearch;
    const int _newUserPaging = 10;
    int _newUserSearchPage = 0;
    bool moreUsers = true;

    string? newText;

    byte[]? fileBytes;
    const int maxFileNameLength = 20;
    bool fileCouldNotBeUploaded;
    bool fileSizeTooLarge;
    bool downloadFailed;
    const long maxFileSize = 50000000;
    
    string noPicString = "Pictures/noPic.png";

    bool hasPreviousConversations = false;
    Conversation currentConvo;
    List<Conversation> _previousConversations = new List<Conversation>();
    List<User> _usersForPreviousConversations = new List<User>();
    List<Message> _currentConvoMessages = new List<Message>();
    const int _convoPaging = 15;
    int _convoPage = 0;
    bool noMoreConversations = false;
    bool hasMessages;
    bool userFound;
    bool clickedUser;
    bool messageNotSent;
    bool messageSentNotFound;
    int lastSeenMessageByReceiver;
    const int _messagePaging = 15;
    int _messagePage = 0;
    bool noMoreMessages = false;

    HashSet<int> timeMap = new HashSet<int>();
    
    bool showDropdown;

    HubConnection? hubConnection;
    
    DotNetObjectReference<Home>? dotNetHelper;
    
    bool shouldScrollToBottom = false;
    bool isFirstConversationClicked = true;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetHelper = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("registerOutsideClick", "userSearchInput", "userSearchDropdown", dotNetHelper);
        }

        if (shouldScrollToBottom)
        {
            // When first conversation clicked, delay needs to happen to scroll to bottom
            if (isFirstConversationClicked)
            {
                await Task.Delay(250);
                isFirstConversationClicked = false;
            }
            shouldScrollToBottom = false;
            await JS.InvokeVoidAsync("scrollToBottom");
        }
    }
    
    [JSInvokable]
    public void CloseDropdown()
    {
        showDropdown = false;
        InvokeAsync(StateHasChanged);
    }
    
    private void ShowDropdown() => showDropdown = true;
    
    protected override async Task OnInitializedAsync()
    {
        _currentUser = await LocalStorage.GetItemAsync<User>("user");
        
        if (_currentUser != null)
        {
            
            await GetConversations();

            await ConnectToWebSocketServer();
        }
        else
        {
            NavMan.NavigateTo("/login");
        }
        
    }

    private async Task GetConversations()
    {
            _convoPage = 0;
            var response = await Client.GetAsync($"conversations/getConversations/{_currentUser.UserId}/{_convoPaging}/{_convoPage}");

            switch (response.StatusCode)
            {
                case HttpStatusCode.OK:
                    noMoreConversations = false;
                    var conversationsContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
                    _previousConversations.AddRange(conversationsContainer.Conversations);

                    foreach (var conversation in _previousConversations)
                    {
                        conversation.Timestamp = conversation.Timestamp.ToLocalTime();
                    }
                    _usersForPreviousConversations.AddRange(conversationsContainer.Users);
                    hasPreviousConversations = true;
                    break;
                
                case HttpStatusCode.Accepted:
                    noMoreConversations = true;
                    var lastConversationContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
                    _previousConversations.AddRange(lastConversationContainer.Conversations);

                    foreach (var conversation in _previousConversations)
                    {
                        conversation.Timestamp = conversation.Timestamp.ToLocalTime();
                    }
                    _usersForPreviousConversations.AddRange(lastConversationContainer.Users);
                    hasPreviousConversations = true;
                    break;
                
                case HttpStatusCode.NoContent:
                    noMoreConversations = true;
                    break;
                
                case HttpStatusCode.Conflict:
                    Console.WriteLine("Oops... Something went wrong");
                    break;
            }
        
        StateHasChanged();
    }

    private async Task GetSpecificConversation(int userId)
    {
        var convoResponse = await Client.GetAsync($"conversations/get/{_currentUser.UserId}/{userId}");

        switch (convoResponse.StatusCode)
        {
            case HttpStatusCode.OK:
                var container = await convoResponse.Content.ReadFromJsonAsync<ConversationUserContainer>();
                currentConvo = container.Conversation;
                if (currentConvo.SenderId != _currentUser.UserId)
                {
                    currentConvo.SeenByReceiver = true;
                    _previousConversations.Find(x => x.ConversationId == currentConvo.ConversationId).SeenByReceiver = true;
                
                    var update = await Client.PostAsJsonAsync($"conversations/updateSeenStatus", currentConvo);
                    if (!update.IsSuccessStatusCode)
                    {
                        Console.WriteLine("An error occured trying to update seen status");
                    }
                }

                hasPreviousConversations = true;
                break;
                
            case HttpStatusCode.NotFound:
                var newConvo = new Conversation
                {
                    ConversationId = 0,
                    LastMessage = "",
                    PersonAId = _currentUser.UserId,
                    PersonBId = userId,
                    SeenByReceiver = false,
                    Timestamp = DateTime.Now,
                    SenderId = _currentUser.UserId
                };
                var existingConvoIndex = _previousConversations.FindIndex(c => c.ConversationId == 0);
                currentConvo = newConvo;

                if (existingConvoIndex != -1)
                {
                    _previousConversations.RemoveAt(existingConvoIndex);
                    _usersForPreviousConversations.RemoveAt(existingConvoIndex);
                }
                
                _previousConversations.Insert(0, currentConvo);
                _usersForPreviousConversations.Insert(0, _otherPerson);   
                
                hasPreviousConversations = true;
                break;
        }
        
        StateHasChanged();
    }

    private async Task GetMessages(int userId)
    {
        _messagePage = 0;
        var response = await Client.GetAsync($"messages/getMessages/{_currentUser.UserId}/{userId}/{_messagePaging}/0");

        if (response.IsSuccessStatusCode)
        {
            noMoreMessages = response.StatusCode == HttpStatusCode.Accepted;
            
            _currentConvoMessages = await response.Content.ReadFromJsonAsync<List<Message>>();
            
            // Find the last seen message by other person
            for (int i = 0; i < _currentConvoMessages.Count; i++)
            {
                if (_currentConvoMessages[i].Sender == _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == true)
                {
                    lastSeenMessageByReceiver = _currentConvoMessages[i].MessageId;
                    break;
                }
            }

            await UpdateSeenMessages();

            foreach (var message in _currentConvoMessages)
            {
                message.Timestamp = message.Timestamp.ToLocalTime();
            }
            
            hasMessages = true;
            shouldScrollToBottom = true;
            StateHasChanged();
        } else if (response.StatusCode == HttpStatusCode.Conflict || response.StatusCode == HttpStatusCode.NotFound)
        {
            _currentConvoMessages = new List<Message>();
            hasMessages = false;
            StateHasChanged();
        }
    }

    private async Task UpdateSeenMessages()
    {
        var newMessages = new List<Message>();
        
        // Update seenByReceiver status for messages received by user
        for (int i = 0; i < _currentConvoMessages.Count; i++)
        {
            if (_currentConvoMessages[i].Sender != _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == false)
            {
                _currentConvoMessages[i].SeenByReceiver = true;
                newMessages.Add(_currentConvoMessages[i]);
            } else if (_currentConvoMessages[i].Sender != _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == true)
            {
                break;
            }
        }

        await Client.PostAsJsonAsync("messages/updateSeen", newMessages);
    }
    
    private async Task OnSearchChange(ChangeEventArgs e)
    {
        _searchedUsers = new List<User>();
        _newUserSearchPage = 0;
        _newUserSearch = e.Value.ToString();
        if (string.IsNullOrEmpty(_newUserSearch))
        {
            moreUsers = false;
            _searchedUsers = new List<User>();
            StateHasChanged();
            return;
        }
        var response = await Client.GetAsync($"auth/getquery/{_newUserSearch}/{_newUserPaging}/0");
        
        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                moreUsers = true;
                _searchedUsers = await response.Content.ReadFromJsonAsync<List<User>>();
                StateHasChanged();
                break;
                
            case HttpStatusCode.Accepted:
                _searchedUsers = await response.Content.ReadFromJsonAsync<List<User>>();
                moreUsers = false;
                StateHasChanged();
                break;
                
            case HttpStatusCode.NoContent:
                moreUsers = false;
                StateHasChanged();
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oh no, something went wrong!!!");
                break;
        }
    }

    private async Task ShowMoreUsers()
    {
        _newUserSearchPage++;
        var response = await Client.GetAsync($"auth/getquery/{_newUserSearch}/{_newUserPaging}/{_newUserSearchPage}");
        
        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                moreUsers = true;
                List<User> newUsers = await response.Content.ReadFromJsonAsync<List<User>>();
                _searchedUsers.AddRange(newUsers);
                break;
                
            case HttpStatusCode.Accepted:
                List<User> lastUsers = await response.Content.ReadFromJsonAsync<List<User>>();
                _searchedUsers.AddRange(lastUsers);
                moreUsers = false;
                break;
                
            case HttpStatusCode.NoContent:
                moreUsers = false;
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oh no, something went wrong!!!");
                break;
                
        }
        StateHasChanged();
    }
    
    private async Task ShowMoreMessages()
    {
        _messagePage++;
        var response = await Client.GetAsync($"messages/getMessages/{_currentUser.UserId}/{_otherPerson.UserId}/{_messagePaging}/{_messagePage}");
        
        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                List<Message> moreMessages = await response.Content.ReadFromJsonAsync<List<Message>>();
                _currentConvoMessages.AddRange(moreMessages);
                noMoreMessages = false;
                break;
                
            case HttpStatusCode.Accepted:
                List<Message> lastMessages = await response.Content.ReadFromJsonAsync<List<Message>>();
                _currentConvoMessages.AddRange(lastMessages);
                noMoreMessages = true;
                break;
                
            case HttpStatusCode.NoContent:
                noMoreMessages = true;
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oh no, something went wrong!!!");
                break;
        }
        StateHasChanged();
    }

    private async Task ShowMoreConversations()
    {
        _convoPage++;
        var response = await Client.GetAsync($"conversations/getConversations/{_currentUser.UserId}/{_convoPaging}/{_convoPage}");

        switch (response.StatusCode)
        {
            case HttpStatusCode.OK:
                noMoreConversations = false;
                var conversationsContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
                _previousConversations.AddRange(conversationsContainer.Conversations);

                foreach (var conversation in _previousConversations)
                {
                    conversation.Timestamp = conversation.Timestamp.ToLocalTime();
                }
                _usersForPreviousConversations.AddRange(conversationsContainer.Users);
                hasPreviousConversations = true;
                break;
                
            case HttpStatusCode.Accepted:
                noMoreConversations = true;
                var lastConversationContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
                _previousConversations.AddRange(lastConversationContainer.Conversations);

                foreach (var conversation in _previousConversations)
                {
                    conversation.Timestamp = conversation.Timestamp.ToLocalTime();
                }
                _usersForPreviousConversations.AddRange(lastConversationContainer.Users);
                hasPreviousConversations = true;
                break;
                
            case HttpStatusCode.NoContent:
                noMoreConversations = true;
                break;
                
            case HttpStatusCode.Conflict:
                Console.WriteLine("Oops... Something went wrong");
                break;
        }
        StateHasChanged();
    }

    private async Task HandleFile(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            if (file.Size > maxFileSize)
            {
                await FileSizeTooLargeError();
                fileBytes = null;
                return;
            }
            using var memoryStream = new MemoryStream();
            await file.OpenReadStream(maxFileSize).CopyToAsync(memoryStream);
            fileBytes = memoryStream.ToArray();

            newText = file.Name.Length > maxFileNameLength ? file.Name.Substring(0, maxFileNameLength) : file.Name;
           
            MessageFileContainer container = new MessageFileContainer
            {
                FileName = file.Name,
                SenderId = _currentUser.UserId,
                File = fileBytes
            };
            var uploadResponse = await Client.PostAsJsonAsync("messages/sendFile", container);
            
            if (uploadResponse.StatusCode == HttpStatusCode.BadRequest)
            {
                await FileCouldNotBeUploadedError();
                return;
            }
            
            var path = await uploadResponse.Content.ReadAsStringAsync();
            
            await SendMessage(true, path);
        }
        else
        {
            fileBytes = null;
        }
    }
    
    private async Task DownloadFile(int messageId)
    {
        var response = await Client.GetAsync($"messages/getFile{messageId}");
        if (response.StatusCode == HttpStatusCode.Conflict)
        {
            await FileCouldNotBeDownloadedError();
            return;
        }
        var NameByteContainer = await response.Content.ReadFromJsonAsync<ByteNameContainer>();
        var asMemStream = new MemoryStream(NameByteContainer.Bytes);

        using var streamRef = new DotNetStreamReference(asMemStream);

        await JS.InvokeVoidAsync("downloadFileFromStream", NameByteContainer.FileName, streamRef);
    }
    
    private void Enter(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        { 
            SendMessage();
        }
    }

    private async Task SendMessage(bool isFile = false, string path = "")
    {
        if (_otherPerson == null || _currentUser == null)
        {
            newText = "";
            return;
        }

        if(string.IsNullOrWhiteSpace(newText))
            return;

        Message newMess;
        
        if (isFile)
        {
            newMess = new Message()
            {
                Content = newText,
                MessageId = 0,
                Receiver = _otherPerson.UserId,
                Sender = _currentUser.UserId,
                Timestamp = DateTime.MinValue,
                IsFile = isFile,
                FileURL = path
            };
        }
        else
        {
            newMess = new Message()
            {
                Content = newText,
                MessageId = 0,
                Receiver = _otherPerson.UserId,
                Sender = _currentUser.UserId,
                Timestamp = DateTime.MinValue,
                IsFile = isFile
            };
        }

        if (currentConvo.LastMessage == "")
        {
            currentConvo.LastMessage = newText;
            var postConvoResponse = await Client.PostAsJsonAsync("conversations/create", currentConvo);
            if (postConvoResponse.IsSuccessStatusCode)
            {
                var convo = await postConvoResponse.Content.ReadFromJsonAsync<Conversation>();
                _previousConversations = new List<Conversation>();
                _usersForPreviousConversations = new List<User>();
                await GetConversations();
                currentConvo = convo;
            }
            else
            {
                Console.WriteLine("Something went wrong starting a new conversation");
            }
            
        }

        
        var response = await Client.PostAsJsonAsync("messages/createMessage", newMess);
        if (response.IsSuccessStatusCode)
        {
            var sentMessageId = await response.Content.ReadFromJsonAsync<int>();
            var newResponse = await Client.GetAsync($"messages/getSentMessage/{sentMessageId}");
            if (newResponse.IsSuccessStatusCode)
            {
                var message = await newResponse.Content.ReadFromJsonAsync<Message>();
                message.Timestamp = message.Timestamp.ToLocalTime();
                _currentConvoMessages.Insert(0, message);
                currentConvo.LastMessage = newText;
                currentConvo.SenderId = _currentUser.UserId;
                currentConvo.SeenByReceiver = false;
                
                hasMessages = true;
                
                var update = await Client.PostAsJsonAsync("conversations/update", currentConvo);
                if (update.IsSuccessStatusCode)
                {
                    var index = _previousConversations.FindIndex(x => x.ConversationId == currentConvo.ConversationId);
                    _previousConversations[index].LastMessage = newText;
                    _previousConversations[index].SenderId = _currentUser.UserId;
                    _previousConversations[index].SeenByReceiver = false;
                    _previousConversations[index].Timestamp = DateTime.UtcNow.ToLocalTime();

                    var zipped = _previousConversations
                        .Zip(_usersForPreviousConversations, (conv, user) => new { conv, user })
                        .OrderByDescending(x => x.conv.Timestamp)
                        .ToList();

                    _previousConversations = zipped.Select(x => x.conv).ToList();
                    _usersForPreviousConversations = zipped.Select(x => x.user).ToList();
                    
                    if (hubConnection is not null)
                        await hubConnection.InvokeAsync("UpdateReceiverMessages", _otherPerson.UserId, _currentUser.UserId);
                    shouldScrollToBottom = true;
                }
                else
                {
                    Console.WriteLine("Something went wrong updating conversations with new text");
                }
                
                newText = "";
                
                StateHasChanged();
            }
            else
            {
                await ShowSentMessageCouldntBeFoundError();
            }
        }
        else
        {
            await ShowMessageNotSentError();
        }

    }

    private async Task ShowMessageNotSentError()
    {
        messageNotSent = true;
        StateHasChanged();
        await Task.Delay(3000);
        messageNotSent = false;
        StateHasChanged();
    }

    private async Task ShowSentMessageCouldntBeFoundError()
    {
        messageSentNotFound = true;
        StateHasChanged();
        await Task.Delay(3000);
        messageNotSent = false;
        StateHasChanged();
    }

    private async Task FileCouldNotBeUploadedError()
    {
        fileCouldNotBeUploaded = true;
        StateHasChanged();
        await Task.Delay(3000);
        fileCouldNotBeUploaded = false;
        StateHasChanged();
    }
    
    private async Task FileCouldNotBeDownloadedError()
    {
        downloadFailed = true;
        StateHasChanged();
        await Task.Delay(3000);
        downloadFailed = false;
        StateHasChanged();
    }
    
    private async Task FileSizeTooLargeError()
    {
        fileSizeTooLarge = true;
        StateHasChanged();
        await Task.Delay(3000);
        fileSizeTooLarge = false;
        StateHasChanged();
    }

    private async Task ConnectToWebSocketServer()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl($"{socketLocalHost}/chatMe?userid={_currentUser.UserId}")
            .Build();

        hubConnection.On<int>("UpdateMessages", UpdateMessages);
        hubConnection.On<int>("UpdateCurrentConvo", UpdateCurrentConvo);
        
        await hubConnection.StartAsync();
    }
    
    // Called from websocket
    private async Task UpdateCurrentConvo(int receiverId)
    {
        if (receiverId == _otherPerson.UserId)
        {
            await GetSpecificConversation(receiverId);

            await GetMessages(receiverId);
        
            clickedUser = true;
        }
        StateHasChanged();
        Console.WriteLine("Messages Updated");
    }
    
    // Called from WebSocket
    private async Task UpdateMessages(int senderId)
    {

        await FindAndUpdateConversation(senderId);
        
        //If the user sending a message is the user you are having a convo with, update specific convo
        if (senderId == _otherPerson.UserId)
        {
            await GetSpecificConversation(senderId);

            await GetMessages(senderId);
        
            clickedUser = true;
            
            await hubConnection.InvokeAsync("ShowSeen", _currentUser.UserId, _otherPerson.UserId);

        }
        StateHasChanged();
        Console.WriteLine("Conversations Updated");
    }

    private async Task FindAndUpdateConversation(int senderId)
    {
        var response = await Client.GetAsync($"conversations/get/{_currentUser.UserId}/{senderId}");
        if (response.IsSuccessStatusCode)
        {
            var container = await response.Content.ReadFromJsonAsync<ConversationUserContainer>();
            container.Conversation.Timestamp = container.Conversation.Timestamp.ToLocalTime();
            var index = _previousConversations.FindIndex(c => c.ConversationId == container.Conversation.ConversationId);
            if (index != -1)
            {
                _previousConversations[index] = container.Conversation;
                _usersForPreviousConversations[index] = container.User;
            }
            else
            {
                if (_previousConversations.Count == _convoPaging * (_convoPage + 1))
                {
                    _previousConversations.RemoveAt(_previousConversations.Count-1);
                    _usersForPreviousConversations.RemoveAt(_usersForPreviousConversations.Count-1);
                }
                _previousConversations.Insert(0, container.Conversation);
                _usersForPreviousConversations.Insert(0, container.User);
            }

            var zipped = _previousConversations.Zip(_usersForPreviousConversations, (convo, user) => new { convo, user })
                .OrderByDescending(tuple => tuple.convo.Timestamp)
                .ToList();
            _previousConversations = zipped.Select(t => t.convo).ToList();
            _usersForPreviousConversations = zipped.Select(t => t.user).ToList();
            StateHasChanged();
        }
    }
    
    private async Task StartConvoWith(int userId)
    {
        showDropdown = false;
        _newUserSearch = "";
        _searchedUsers = new List<User>();
        var userResponse = await Client.GetAsync($"auth/getUser/{userId}");

        if (userResponse.IsSuccessStatusCode)
        {
            _otherPerson = await userResponse.Content.ReadFromJsonAsync<User>();
            userFound = true;
        }
        else
        {
            clickedUser = true;
            userFound = false;
            StateHasChanged();
            return;
        }

        await GetSpecificConversation(userId);

        await GetMessages(userId);
        
        clickedUser = true;

        if (_currentConvoMessages.Count > 0)
        {
            await hubConnection.InvokeAsync("UpdateReceiverMessages", userId, _currentUser.UserId);
        }
    }

    private void ShowTimestamp(int messageMessageId)
    {

        if (!timeMap.Add(messageMessageId))
        {
            timeMap.Remove(messageMessageId);
        }

        if (timeMap.Count > 1)
        {
            timeMap.Clear();
            timeMap.Add(messageMessageId);
        }
        
        StateHasChanged();
    }

    private async Task OpenConvoCard(int personA, int personB)
    {
        if (personA == _currentUser.UserId)
            await StartConvoWith(personB);
        else
            await StartConvoWith(personA);
    }

    

}