@page "/"
@using System.Net
@using Microsoft.AspNetCore.SignalR.Client
@using Core
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject NavigationManager NavMan
@inject HttpClient Client
@inject IJSRuntime JS

<PageTitle>Messages</PageTitle>

<!-- Todo: 
    2. Error messages show up wrong (can be tested with fileSizeTooLarge)
    5. Reduce redundancy in code (make some code into functions)
    6. Make the app work with phone
    7. Screen resolution on create profile
    8. Make 'update Seen status' on messages better (not sending ALL messages)
-->

@if (_currentUser == null)
{
    <div style="display: flex; justify-content: center; align-items: center; flex-direction: column; height: 100vh;">
        <div class="loader"></div>
        <span>Authenticating...</span>
    </div>
}
else
{
    <div class="main">
        
        @if (messageNotSent)
        {
            <div class="alert alert-danger" role="alert">
                Message could not be sent
            </div>
        } else if (messageSentNotFound)
        {
            <div class="alert alert-danger" role="alert">
                Message could not be found in the database
            </div>
        } else if (fileCouldNotBeUploaded)
        {
            <div class="alert alert-danger" role="alert">
                File could not be uploaded
            </div>
        } else if (fileSizeTooLarge)
        {
            <div class="alert alert-danger" role="alert">
                File size too large
            </div>
        } else if (downloadFailed)
        {
            <div class="alert alert-danger" role="alert">
                File could not be downloaded
            </div>
        }

        <div class="usersDiv">

            <div class="userSearchDiv">
                <InputText @bind-Value="_newUserSearch" id="userSearchInput"
                           @oninput="OnSearchChange"
                           @onfocus="ShowDropdown"
                           placeholder="Start new conversation..." class="inputStyle"></InputText>
                @if (showDropdown)
                {
                    <div class="searchedPeoplesDropdown" id="userSearchDropdown">
                        @if (_searchedUsers.Count == 0 && string.IsNullOrWhiteSpace(_newUserSearch))
                        {
                            <p>Begin searching for a user to connect with</p>
                        }
                        else
                        {
                            if (_searchedUsers.Count > 0)
                            {
                                @foreach (var user in _searchedUsers)
                                {
                                    @if (!string.IsNullOrWhiteSpace(_newUserSearch))
                                    {
                                        <div @onclick="() => StartConvoWith(user.UserId)" class="userCard">
                                            <img alt="profile pic" src="@(user.ProfilePicture ?? "Pictures/noPic.png")"/>
                                            <span>@user.FirstName @user.LastName</span>
                                        </div>
                                    }
                                }
                            }
                            else
                            {
                                <p>No user with name found</p>
                            }
                        }
                    </div>
                }
            </div>

            <div class="conversationsDiv">
                @if (hasPreviousConversations)
                {
                    // Two List, one for conversations, other for user tied to the conversations.
                    // Determines whether to show current users name, or other user
                    @foreach (var (x, y) in _previousConversations.Zip(_usersForPreviousConversations))
                    {
                        <div class="convoCard" @onclick="() => OpenConvoCard(x.PersonAId, x.PersonBId)">
                            <img alt="convo profile pic" src="@(y.ProfilePicture ?? "Pictures/noPic.png")"/>

                            <div class="convoCardBuffer">
                                <span>@y.FirstName @y.LastName</span>

                                @if (x.SenderId != _currentUser.UserId && x.SeenByReceiver)
                                {
                                    <span style="font-size: 14px; color: grey">@y.FirstName @y.LastName: @x.LastMessage</span>
                                    <span style="font-size: 14px; color: grey">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>

                                }
                                else if (x.SenderId != _currentUser.UserId && x.SeenByReceiver == false)
                                {
                                    <span style="font-size: 14px; color: black"><b>@y.FirstName @y.LastName: @x.LastMessage</b></span>
                                    <span style="font-size: 14px; color: black">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>
                                }
                                else
                                {
                                    <span style="font-size: 14px; color: grey">You: @x.LastMessage</span>
                                    <span style="font-size: 14px; color: grey">@(x.Timestamp.Day == DateTime.Now.Day ? x.Timestamp.ToString("HH:mm") : x.Timestamp.Year == DateTime.Now.Year ? x.Timestamp.ToString("dd-MMMM") : x.Timestamp.ToString("dd-MMMM-yyy"))</span>
                                }
                            </div>
                        </div>
                    }
                }
            </div>

        </div>

        <div class="messagesDiv">
            <div class="convoBanner">
                <div>
                    @if (userFound)
                    {
                        <img alt="profile pic" src="@(_otherPerson.ProfilePicture ?? "Pictures/noPic.png")"/>
                        <span>@_otherPerson.FirstName @_otherPerson.LastName</span>
                    }
                </div>

                <div style="display: flex">
                    <div id="myProfileLink">
                        <a href="/myprofile">My Profile</a>
                    </div>

                    <div id="logoutLink">
                        <a href="/logout">Logout</a>
                    </div>
                </div>

            </div>
            <div class="messagesContainer">
                @if (userFound && hasMessages && clickedUser && _currentConvoMessages.Count > 0)
                {
                    foreach (var message in _currentConvoMessages)
                    {
                        if (timeMap.Contains(message.MessageId))
                        {
                            <span class="messageTimestamp">@(message.Timestamp.Day == DateTime.Now.Day ? message.Timestamp.ToString("HH:mm") : message.Timestamp.ToString("dd-MMMM HH:mm"))</span>
                        }

                        if (message.Sender == _currentUser.UserId)
                        {
                            <div class="bufferDiv">
                                <div class="userMessage" @onclick="() => ShowTimestamp(message.MessageId)">
                                    @if (message.IsFile)
                                    {
                                        <span @onclick="() => DownloadFile(message.MessageId)" style="color: blue; text-decoration: underline" class="messageContent">@message.Content</span>
                                    }
                                    else
                                    {
                                        <span class="messageContent">@message.Content</span>
                                    }
                                    
                                </div>
                                @if (message.MessageId == lastSeenMessageByReceiver)
                                {
                                    <img id="seenPicture" alt="picture of other person" src=@(_otherPerson.ProfilePicture ?? "Pictures/noPic.png")/>
                                }
                            </div>
                        }
                        else
                        {
                            <div class="receiverMessage" @onclick="() => ShowTimestamp(message.MessageId)">
                                @if (message.IsFile)
                                {
                                    <span @onclick="() => DownloadFile(message.MessageId)" style="color: blue; text-decoration: underline" class="messageContent">@message.Content</span>
                                }
                                else
                                {
                                    <span class="messageContent">@message.Content</span>
                                }
                            </div>
                        }
                    }
                }
                else if (!userFound && clickedUser)
                {
                    <p>This user does not exist??</p>
                }
                else if (!hasMessages && clickedUser)
                {
                    <p>Begin your conversation with @_otherPerson.FirstName @_otherPerson.LastName</p>
                }
            </div>

            <div class="inputDiv">
                <InputText @bind-Value="newText" @onkeyup="Enter" class="inputMessage" placeholder="Send message"></InputText>
                <svg @onclick="() => SendMessage()" class="sendIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M15.854.146a.5.5 0 0 1 .11.54l-5.819 14.547a.75.75 0 0 1-1.329.124l-3.178-4.995L.643 7.184a.75.75 0 0 1 .124-1.33L15.314.037a.5.5 0 0 1 .54.11ZM6.636 10.07l2.761 4.338L14.13 2.576zm6.787-8.201L1.591 6.602l4.339 2.76z"/>
                </svg>
                <InputFile OnChange="HandleFile" size=""></InputFile>
            </div>
        </div>

    </div>
        
}



@code{
    string socketAzure = "https://chatappmesocket.azurewebsites.net";
    string socketLocalHost = "http://localhost:5150";
    
    User? _currentUser;
    User? _otherPerson;

    List<User> _searchedUsers = new List<User>();
    string? _newUserSearch;

    string? newText;

    byte[]? fileBytes;
    int maxFileNameLength = 20;
    bool fileCouldNotBeUploaded;
    bool fileSizeTooLarge;
    bool downloadFailed;
    long maxFileSize = 50000000;
    
    string noPicString = "Pictures/noPic.png";

    bool hasPreviousConversations = false;
    Conversation currentConvo;
    List<Conversation> _previousConversations = new List<Conversation>();
    List<User> _usersForPreviousConversations = new List<User>();
    List<Message> _currentConvoMessages;
    bool hasMessages;
    bool userFound;
    bool clickedUser;
    bool messageNotSent;
    bool messageSentNotFound;
    int lastSeenMessageByReceiver;

    HashSet<int> timeMap = new HashSet<int>();
    
    bool showDropdown;

    HubConnection? hubConnection;
    
    DotNetObjectReference<Home>? dotNetHelper;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetHelper = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("registerOutsideClick", "userSearchInput", "userSearchDropdown", dotNetHelper);
        }
    }
    
    [JSInvokable]
    public void CloseDropdown()
    {
        showDropdown = false;
        InvokeAsync(StateHasChanged);
    }
    
    private void ShowDropdown() => showDropdown = true;
    
    protected override async Task OnInitializedAsync()
    {
        _currentUser = await LocalStorage.GetItemAsync<User>("user");
        
        if (_currentUser != null)
        {
            
            await GetConversations();

            await ConnectToWebSocketServer();
        }
        else
        {
            NavMan.NavigateTo("/login");
        }
    }

    private async Task GetConversations()
    {
        var response = await Client.GetAsync($"conversations/getConversations/{_currentUser.UserId}");
        if (response.StatusCode == HttpStatusCode.NotFound)
        {
            _previousConversations = new List<Conversation>();
            _usersForPreviousConversations = new List<User>();
        } else if (response.IsSuccessStatusCode)
        {
            var conversationsContainer = await response.Content.ReadFromJsonAsync<ConversationsUsersContainer>();
            _previousConversations = conversationsContainer.Conversations;

            foreach (var conversation in _previousConversations)
            {
                conversation.Timestamp = conversation.Timestamp.ToLocalTime();
            }
            _usersForPreviousConversations = conversationsContainer.Users;
            hasPreviousConversations = true;
        }
    }

    private async Task GetSpecificConversation(int userId)
    {
        var convoResponse = await Client.GetAsync($"conversations/get/{_currentUser.UserId}/{userId}");
        if (convoResponse.StatusCode == HttpStatusCode.NotFound)
        {
            var newConvo = new Conversation
            {
                ConversationId = 0,
                LastMessage = "",
                PersonAId = _currentUser.UserId,
                PersonBId = userId,
                SeenByReceiver = false,
                Timestamp = DateTime.Now,
                SenderId = _currentUser.UserId
            };
            var newConvoResponse = await Client.PostAsJsonAsync("conversations/create", newConvo);

            if (newConvoResponse.IsSuccessStatusCode)
            {
                currentConvo = await newConvoResponse.Content.ReadFromJsonAsync<Conversation>();
                currentConvo.Timestamp = currentConvo.Timestamp.ToLocalTime();
                _previousConversations.Add(currentConvo);
                _usersForPreviousConversations.Add(_otherPerson);
                hasPreviousConversations = true;
            }
            else
            {
                Console.WriteLine("An error occured trying to create a new conversation");
            }
            StateHasChanged();
            
        } else if (convoResponse.IsSuccessStatusCode)
        {
            currentConvo = await convoResponse.Content.ReadFromJsonAsync<Conversation>();
            if (currentConvo.SenderId != _currentUser.UserId)
            {
                currentConvo.SeenByReceiver = true;
                _previousConversations.Find(x => x.ConversationId == currentConvo.ConversationId).SeenByReceiver = true;
                
                var update = await Client.PostAsJsonAsync($"conversations/updateSeenStatus", currentConvo);
                if (!update.IsSuccessStatusCode)
                {
                    Console.WriteLine("An error occured trying to update seen status");
                }
            }
        }
    }

    private async Task GetMessages(int userId)
    {
        var response = await Client.GetAsync($"messages/getMessages/{_currentUser.UserId}/{userId}");

        if (response.IsSuccessStatusCode)
        {
            _currentConvoMessages = await response.Content.ReadFromJsonAsync<List<Message>>();
            
            // Find the last seen message by other person
            for (int i = _currentConvoMessages.Count - 1; i >= 0; i--)
            {
                if (_currentConvoMessages[i].Sender == _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == true)
                {
                    lastSeenMessageByReceiver = _currentConvoMessages[i].MessageId;
                    break;
                }
            }

            // Update seenByReceiver status for messages received by user
            for (int i = _currentConvoMessages.Count - 1; i >= 0; i--)
            {
                if (_currentConvoMessages[i].Sender != _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == false)
                {
                    _currentConvoMessages[i].SeenByReceiver = true;
                } else if (_currentConvoMessages[i].Sender != _currentUser.UserId && _currentConvoMessages[i].SeenByReceiver == true)
                {
                    break;
                }
            }

            foreach (var message in _currentConvoMessages)
            {
                message.Timestamp = message.Timestamp.ToLocalTime();
            }
            
            hasMessages = true;
            StateHasChanged();
        } else if (response.StatusCode == HttpStatusCode.Conflict)
        {
            _currentConvoMessages = new List<Message>();
            hasMessages = false;
            StateHasChanged();
        }
    }
    
    private async Task OnSearchChange(ChangeEventArgs e)
    {
        _newUserSearch = e.Value.ToString();
        var response = await Client.GetAsync($"auth/getquery/{_newUserSearch}");
        if (response.IsSuccessStatusCode)
        {
            _searchedUsers = await response.Content.ReadFromJsonAsync<List<User>>();
            StateHasChanged();
        } else if (response.StatusCode == HttpStatusCode.NotFound)
        {
            _searchedUsers = new List<User>();
            StateHasChanged();
        }
    }

    private async Task HandleFile(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            if (file.Size > maxFileSize)
            {
                fileSizeTooLarge = true;
                return;
            }
            using var memoryStream = new MemoryStream();
            await file.OpenReadStream(maxFileSize).CopyToAsync(memoryStream);
            fileBytes = memoryStream.ToArray();

            newText = file.Name.Length > maxFileNameLength ? file.Name.Substring(0, maxFileNameLength) : file.Name;
           
            MessageFileContainer container = new MessageFileContainer
            {
                FileName = file.Name,
                SenderId = _currentUser.UserId,
                File = fileBytes
            };
            var uploadResponse = await Client.PostAsJsonAsync("messages/sendFile", container);
            
            if (uploadResponse.StatusCode == HttpStatusCode.BadRequest)
            {
                fileCouldNotBeUploaded = true;
                StateHasChanged();
                return;
            }
            
            var path = await uploadResponse.Content.ReadAsStringAsync();
            
            await SendMessage(true, path);
        }
        else
        {
            fileBytes = null;
            fileCouldNotBeUploaded = false;
            fileSizeTooLarge = false;
        }
    }
    
    private async Task DownloadFile(int messageId)
    {
        var response = await Client.GetAsync($"messages/getFile{messageId}");
        if (response.StatusCode == HttpStatusCode.Conflict)
        {
            downloadFailed = true;
            return;
        }
        var NameByteContainer = await response.Content.ReadFromJsonAsync<ByteNameContainer>();
        var asMemStream = new MemoryStream(NameByteContainer.Bytes);

        using var streamRef = new DotNetStreamReference(asMemStream);

        await JS.InvokeVoidAsync("downloadFileFromStream", NameByteContainer.FileName, streamRef);
    }
    
    private void Enter(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        { 
            SendMessage();
        }
    }

    private async Task SendMessage(bool isFile = false, string path = "")
    {
        if (_otherPerson == null || _currentUser == null)
        {
            newText = "";
            return;
        }

        if(string.IsNullOrWhiteSpace(newText))
            return;

        Message newMess;
        
        if (isFile)
        {
            newMess = new Message()
            {
                Content = newText,
                MessageId = 0,
                Receiver = _otherPerson.UserId,
                Sender = _currentUser.UserId,
                Timestamp = DateTime.MinValue,
                IsFile = isFile,
                FileURL = path
            };
        }
        else
        {
            newMess = new Message()
            {
                Content = newText,
                MessageId = 0,
                Receiver = _otherPerson.UserId,
                Sender = _currentUser.UserId,
                Timestamp = DateTime.MinValue,
                IsFile = isFile
            };
        }

        
        var response = await Client.PostAsJsonAsync("messages/createMessage", newMess);
        if (response.IsSuccessStatusCode)
        {
            var sentMessageId = await response.Content.ReadFromJsonAsync<int>();
            var newResponse = await Client.GetAsync($"messages/getSentMessage/{sentMessageId}");
            if (newResponse.IsSuccessStatusCode)
            {
                var message = await newResponse.Content.ReadFromJsonAsync<Message>();
                message.Timestamp = message.Timestamp.ToLocalTime();
                _currentConvoMessages.Add(message);
                currentConvo.LastMessage = newText;
                currentConvo.SenderId = _currentUser.UserId;
                currentConvo.SeenByReceiver = false;
                
                if (!hasMessages)
                    hasMessages = true;
                
                var update = await Client.PostAsJsonAsync("conversations/update", currentConvo);
                if (update.IsSuccessStatusCode)
                {
                    var index = _previousConversations.FindIndex(x => x.ConversationId == currentConvo.ConversationId);
                    _previousConversations[index].LastMessage = newText;
                    _previousConversations[index].SenderId = _currentUser.UserId;
                    _previousConversations[index].SeenByReceiver = false;
                    _previousConversations[index].Timestamp = DateTime.UtcNow.ToLocalTime();

                    var zipped = _previousConversations
                        .Zip(_usersForPreviousConversations, (conv, user) => new { conv, user })
                        .OrderByDescending(x => x.conv.Timestamp)
                        .ToList();

                    _previousConversations = zipped.Select(x => x.conv).ToList();
                    _usersForPreviousConversations = zipped.Select(x => x.user).ToList();
                    
                    if (hubConnection is not null)
                        await hubConnection.InvokeAsync("UpdateReceiverMessages", _otherPerson.UserId, _currentUser.UserId);
                }
                else
                {
                    Console.WriteLine("Something went wrong updating conversations with new text");
                }
                
                newText = "";
                
                StateHasChanged();
            }
            else
            {
                await ShowSentMessageCouldntBeFoundError();
            }
        }
        else
        {
            await ShowMessageNotSentError();
        }

    }

    private async Task ShowMessageNotSentError()
    {
        messageNotSent = true;
        StateHasChanged();
        await Task.Delay(3000);
        messageNotSent = false;
        StateHasChanged();
    }

    private async Task ShowSentMessageCouldntBeFoundError()
    {
        messageSentNotFound = true;
        StateHasChanged();
        await Task.Delay(3000);
        messageNotSent = false;
        StateHasChanged();
    }

    private async Task ConnectToWebSocketServer()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl($"{socketAzure}/chatMe?userid={_currentUser.UserId}")
            .Build();

        hubConnection.On<int>("UpdateMessages", UpdateMessages);
        hubConnection.On<int>("UpdateCurrentConvo", UpdateCurrentConvo);
        
        await hubConnection.StartAsync();
    }
    
    // Called from websocket
    private async Task UpdateCurrentConvo(int receiverId)
    {
        if (receiverId == _otherPerson.UserId)
        {
            await GetSpecificConversation(receiverId);

            await GetMessages(receiverId);
        
            clickedUser = true;

            if (_currentConvoMessages.Count > 0)
                await Client.PostAsJsonAsync("messages/updateSeen", _currentConvoMessages);
            
        }
        StateHasChanged();
        Console.WriteLine("Messages Updated");
    }
    
    // Called from WebSocket
    private async Task UpdateMessages(int senderId)
    {
        
        await GetConversations();

        if (senderId == _otherPerson.UserId)
        {
            await GetSpecificConversation(senderId);

            await GetMessages(senderId);
        
            clickedUser = true;

            if (_currentConvoMessages.Count > 0)
                await Client.PostAsJsonAsync("messages/updateSeen", _currentConvoMessages);
            
            await hubConnection.InvokeAsync("ShowSeen", _currentUser.UserId, _otherPerson.UserId);

        }
        StateHasChanged();
        Console.WriteLine("Messages Updated");
    }
    
    private async Task StartConvoWith(int userId)
    {
        showDropdown = false;
        _newUserSearch = "";
        var userResponse = await Client.GetAsync($"auth/getUser/{userId}");

        if (userResponse.IsSuccessStatusCode)
        {
            _otherPerson = await userResponse.Content.ReadFromJsonAsync<User>();
            userFound = true;
        }
        else
        {
            clickedUser = true;
            userFound = false;
            StateHasChanged();
            return;
        }

        await GetSpecificConversation(userId);

        await GetMessages(userId);
        
        clickedUser = true;

        if (_currentConvoMessages.Count > 0)
        {
            await Client.PostAsJsonAsync("messages/updateSeen", _currentConvoMessages);
            await hubConnection.InvokeAsync("UpdateReceiverMessages", userId, _currentUser.UserId);

        }
    }

    private void ShowTimestamp(int messageMessageId)
    {

        if (!timeMap.Add(messageMessageId))
        {
            timeMap.Remove(messageMessageId);
        }

        if (timeMap.Count > 1)
        {
            timeMap.Clear();
            timeMap.Add(messageMessageId);
        }
        
        StateHasChanged();
    }

    private async Task OpenConvoCard(int personA, int personB)
    {
        if (personA == _currentUser.UserId)
            await StartConvoWith(personB);
        else
            await StartConvoWith(personA);
    }

    

}